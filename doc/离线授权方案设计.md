# OCR2Doc 离线授权方案设计 (v2)

## 1. 方案概述

本方案为OCR2Doc项目设计一套完整的**纯离线授权**系统，包括服务端授权管理和客户端授权验证。系统采用"授权码-席位"模型，通过交换离线文件（绑定/授权文件）完成激活，并支持安全的**授权转移**（解绑/重绑定）。

### 1.1 设计目标

- **完全离线**：客户端在激活、验证和运行过程中**无需任何网络连接**。
- **安全可控**：采用RSA-2048非对称加密，防止授权伪造；授权与硬件绑定。
- **授权转移**：支持在旧设备上安全解绑，释放授权席位，以便在新设备上激活。
- **模型简化**：软件只有"未授权"、"试用"和"正式授权"状态，通过有效期区分。
- **席位管理**：一个授权码关联一个客户和固定的设备授权数（席位）。

### 1.2 技术架构

```
┌──────────────────┐      ┌──────────┐      ┌──────────────────┐
│   授权服务端     │      │   U盘等   │      │   OCR2Doc客户端  │
│  (LicenseCenter) │      │  离线介质  │      │    (永不联网)    │
│                  │      │          │      │                  │
│  ┌───────────┐   │      │          │      │  ┌───────────┐   │
│  │ 授权管理UI│   │◄─────► Bind/License ◄───►│  │ 授权管理  │   │
│  └───────────┘   │      │   文件   │      │  └───────────┘   │
│  ┌───────────┐   │      │          │      │  ┌───────────┐   │
│  │ SQLite数据库│   │      └──────────┘      │  │ 本地授权  │   │
│  └───────────┘   │                        │  └───────────┘   │
└──────────────────┘                        └──────────────────┘
```

## 2. 核心工作流程

### 2.1 客户控制台与登录

为了提供统一的管理界面，所有面向客户的操作都将在一个安全的网页控制台（Dashboard）中进行。

#### 2.1.1 登录与防机器人验证
客户通过其唯一的**授权码**来访问控制台。为防止授权码被恶意程序暴力破解或滥用，登录页面必须集成防机器人验证机制。

-   **方案建议**: 推荐使用 **hCaptcha** 或 Google reCAPTCHA v2。用户在输入授权码后，需要完成一次人机验证挑战。
-   **登录流程**:
    1.  用户在登录页面输入`授权码`。
    2.  用户完成 hCaptcha 人机验证，获得一个一次性的`验证令牌`。
    3.  前端将`授权码`和`验证令牌`一并提交给服务端。
    4.  服务端首先向 hCaptcha 的验证服务器确认`验证令牌`的有效性，通过后再验证`授权码`。
    5.  验证成功后，服务端返回一个具有时效性（如1小时）的`Session Token`，用于后续所有API请求的身份认证。

#### 2.1.2 客户控制台 (Dashboard) 概览
成功登录后，用户将看到一个清晰的控制台界面，展示所有与授权相关的信息和操作。

**UI界面设计草图:**
```
+-----------------------------------------------------------------------------+
| OCR2Doc 授权管理控制台                                       [注销登录] |
+-----------------------------------------------------------------------------+
| 欢迎, [客户名称]                                                            |
| 您的授权码: ABC-DEF-GHI                                                     |
|                                                                             |
| 授权席位状态:  3 / 10 (已用/总量)                                            |
+-----------------------------------------------------------------------------+
|                                                                             |
| [ 功能区 ]                                                                  |
|                                                                             |
|  ┌───────────────────┐        ┌───────────────────────┐                     |
|  │   新设备授权      │        │      转移授权         │                     |
|  └───────────────────┘        └───────────────────────┘                     |
|    (支持批量上传.bind文件)         (上传.unbind和.bind文件)                     |
|                                                                             |
+-----------------------------------------------------------------------------+
| [ 已激活设备列表 (3) ]                                                      |
+-----------------------------------------------------------------------------+
| 主机名        | 机器ID (部分)     | 激活日期     | 到期日期     | 操作        |
|---------------+-------------------+--------------+--------------+-------------|
| DESIGN-PC-01  | c875d9a8a5...     | 2024-07-30   | 2025-07-29   | [下载.license] |
| LAB-SERVER-02 | ffe312aabc...     | 2024-07-28   | 2025-07-27   | [下载.license] |
| DEV-VM-W11    | 1b9a4d8721...     | 2024-06-15   | 2025-06-14   | [下载.license] |
+-----------------------------------------------------------------------------+
| [ 已解绑/历史设备列表 (1) ]                                                 |
+-----------------------------------------------------------------------------+
| 主机名        | 机器ID (部分)     | 解绑日期     | 原始到期日   | 状态        |
|---------------+-------------------+--------------+--------------+-------------|
| OLD-PC-007    | 9a8b7c6d5e...     | 2024-07-29   | 2025-07-28   | 已转移      |
+-----------------------------------------------------------------------------+
```

### 2.2 新设备激活流程

1.  **客户端 (新设备)**：用户在未授权的设备上运行程序，生成包含**机器ID**和**主机名**的`.bind`文件。如果需要激活多台设备，则生成多个`.bind`文件。
2.  **离线传输**：用户收集所有需要激活的`.bind`文件（例如 `a.bind`, `b.bind`）。
3.  **服务端 (控制台)**：用户登录控制台，进入"新设备授权"功能区，批量上传这些`.bind`文件。
4.  **服务端**：系统检查可用席位是否足够（即 `max_seats - used_seats >= 上传文件数量`）。如果足够，则为每一个上传的`.bind`文件执行授权操作，并消耗相应数量的席位。
5.  **生成与下载**：对于每个`.bind`文件，服务端执行以下操作：
    *   **计算有效期**: 新授权的到期时间 (`expires_at`) 将根据授权码设定的 `duration_years` (从当前时间计算) 和 `latest_expiry_date` (固定日期)来决定，取两者中较早的日期。
    *   **生成授权**: 按照标准流程（含一次性解绑密钥）生成`.license`文件。
    *   **更新计数**: 将对应`authorizations`记录的`used_seats`字段加1。
    *   所有`.license`文件生成后，打包成一个ZIP文件供用户下载，且文件名与上传的`.bind`文件对应（如 `a.license`, `b.license`）。
6.  **客户端激活**：用户将对应的`.license`文件分发到各新设备上并导入，完成激活。

### 2.3 授权转移流程

此流程将旧设备的解绑和新设备的激活合并为一个原子操作，确保席位不会被凭空占用或丢失，并延续授权有效期。

1.  **客户端 (旧设备)**：用户在旧设备上点击"取消授权"，生成`.unbind`文件（此过程与之前定义一致）。本地授权立即失效。
2.  **客户端 (新设备)**：用户在新设备上生成新的`.bind`文件。
3.  **离线传输**：用户将旧设备的`.unbind`文件和新设备的`.bind`文件都拷贝到联网电脑。
4.  **服务端 (控制台)**：用户登录控制台，进入"转移授权"功能区，同时上传这两个文件。
5.  **服务端**：系统执行以下原子化操作：
    *   **验证解绑文件**：对`.unbind`文件进行双重验证，确认其合法性。
    *   **处理席位与记录**: 验证通过后，将旧设备记录标记为`unbound`。由于是转移操作，`used_seats`的总数保持不变。
    *   **生成新授权**：使用新的`.bind`文件和**旧授权的到期日期**来生成新的`.license`文件。新授权将继承旧授权的所有属性，只是绑定了新的机器ID和主机名。
6.  **激活新设备**：用户下载新生成的`.license`文件，拷贝回新设备并导入，完成授权转移。

## 3. 数据库设计 (简化版)

### 3.1 客户与授权码表 (authorizations)

管理客户购买的授权码、席位、有效期规则等核心信息。

```sql
CREATE TABLE authorizations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    customer_name VARCHAR(255) NOT NULL,
    authorization_code VARCHAR(255) UNIQUE NOT NULL, -- 客户购买的唯一授权码
    max_seats INTEGER NOT NULL, -- 总席位数
    used_seats INTEGER NOT NULL DEFAULT 0, -- 已使用席位数，在激活和解绑时更新
    duration_years INTEGER, -- 授权年限 (例如 1, 5, 99 表示永久)。优先级低于 latest_expiry_date
    latest_expiry_date DATETIME, -- 最晚过期时间点，所有基于此授权码生成的license有效期不能超过此日期
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    status INTEGER DEFAULT 1 -- 1:有效 0:禁用
);
```

### 3.2 已激活设备表 (activated_licenses)

记录每一台被激活的设备。

```sql
CREATE TABLE activated_licenses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    authorization_id INTEGER NOT NULL,
    license_key TEXT UNIQUE NOT NULL, -- .license文件内容的哈希或唯一标识
    machine_id VARCHAR(255) NOT NULL, -- 绑定的机器ID
    hostname VARCHAR(255), -- 客户端主机名，方便用户辨识
    unbind_public_key TEXT, -- 用于验证解绑凭证的一次性公钥
    issued_at DATETIME NOT NULL,
    expires_at DATETIME,
    status VARCHAR(50) NOT NULL, -- 'active', 'unbound' (已解绑)
    activated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    unbound_at DATETIME,
    FOREIGN KEY (authorization_id) REFERENCES authorizations (id)
);
```

### 3.3 密钥管理表 (rsa_keys) - (无变化)

```sql
CREATE TABLE rsa_keys (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    private_key TEXT NOT NULL,
    public_key TEXT NOT NULL,
    is_active INTEGER DEFAULT 1
);
```

## 4. 文件格式定义

### 4.1 绑定请求文件 (`.bind`)

一个简单的JSON，包含用于绑定授权的机器信息和主机名。

```json
{
    "hostname": "DESIGN-PC-01",
    "machine_id": "c875d9a8a5843408a28896a297f6c326b5d3a549d4352163140a3317c24a354b",
    "request_time": "2024-07-30T10:00:00Z"
}
```

### 4.2 授权文件 (`.license`)

包含授权信息和签名的核心文件。为了实现安全的解绑，服务端在生成授权时，会额外生成一对一次性的解绑密钥，并将私钥嵌入授权数据中。

```json
{
    "license_data": {
        "machine_id": "c875d9a8a5843408a28896a297f6c326b5d3a549d4352163140a3317c24a354b",
        "issued_at": "2024-07-30T10:05:00Z",
        "expires_at": "2025-07-30T23:59:59Z",
        "license_type": "FULL",
        "unbind_private_key": "base64编码的(一次性解绑私钥)"
    },
    "signature": "base64编码的(对整个license_data使用'服务端主私钥'的RSA签名)"
}
```

### 4.3 解绑凭证文件 (`.unbind`)

用于向服务端证明客户端已执行解绑操作。

```json
{
    "signed_license": {
        "license_data": { ... },
        "signature": "..."
    },
    "unbind_proof": "base64编码的(对整个signed_license使用'一次性解绑私钥'的RSA签名)"
}
```
**解绑凭证生成与验证逻辑**：
1.  **生成**：客户端从其持有的`.license`文件中提取出`unbind_private_key`，并用这个私钥对整个`.license`文件内容（即`signed_license`部分）进行签名，生成`unbind_proof`。
2.  **验证**：服务端收到`.unbind`文件后，首先用**服务端主公钥**验证`signed_license.signature`，确保授权本身是合法的。然后，根据授权信息从数据库查出对应的**一次性解绑公钥**，用它来验证`unbind_proof`。双重验证确保解绑请求来自一个合法的、且真正执行了解绑操作的客户端。

## 5. 安全机制设计

### 5.1 加密与签名

- **RSA-2048**：用于对`.license`授权文件和`.unbind`解绑凭证进行数字签名，确保其不可伪造和篡改。
- **SHA-256**：用于生成机器唯一标识，确保其一致性和匿名性。
- **人机验证 (Captcha)**: 用于保护登录入口，防止自动化脚本攻击。

### 5.2 防篡改机制

1.  **服务端主签名**：`.license`授权文件由服务端主私钥签名，客户端内置主公钥进行验证，防止授权内容被篡改。
2.  **机器绑定**：授权文件与唯一的机器ID绑定，防止授权文件在不同设备间复制使用。
3.  **安全解绑凭证**：解绑流程采用"一次性密钥"机制。解绑能力（即一次性私钥）由服务端在授权时授予，并安全地封装在主签名之内。只有持有合法授权的客户端才能提取出这把私钥，生成有效的解绑证明。这可以防止没有授权的人或仅窃取了`.license`文件的第三方恶意发起解绑。

#### 5.2.1 客户端伪造风险说明
本方案设计的核心是信任链的传递，而非绝对的防破解。需要明确一点：**任何运行在客户端上的代码和数据，对于有足够技术能力和决心的用户来说，理论上都是透明和可分析的。**

用户在了解上述完整的算法流程后，确实存在"假解绑"的可能：
-   **行为**：用户可以编写一个独立的程序，模拟客户端的解绑操作（提取一次性私钥、签名），生成合法的`.unbind`文件并发送给服务端以释放席位，但**同时在本地保留原始的`.license`授权文件而不使其失效**，从而实现"一号多用"。
-   **定性**：这种行为本质上不属于"伪造"签名，而是利用了对客户端环境的完全控制权，绕过了客户端的"解绑后自毁"的约定。这应被视为一种**客户端破解行为**。
-   **应对**：对此类风险的防御，重心在于提升客户端的逆向工程难度，例如代码混淆、加壳、完整性校验等，这些属于客户端软件保护的范畴，已超出授权协议设计的范畴。

### 5.3 防系统时间篡改

为防止用户通过修改系统时间来绕过有效期限制，客户端应实施以下策略：
- **安全时间戳**：在本地一个隐蔽位置（如注册表、特定文件）加密存储上一次成功运行的系统时间。
- **启动校验**：每次启动时，读取并解密该时间戳。如果当前系统时间早于记录的"上次运行时间"，则判定为时间篡改，**拒绝运行**并提示用户修正系统时间。

## 6. API接口设计 (文件交换模式)

所有接口（除登录外）都需要在HTTP Header中提供`Authorization: Bearer <session_token>`。

### 6.1 登录接口

```http
POST /api/v1/login
Content-Type: application/json

{
    "authorization_code": "...",
    "captcha_token": "..."
}
```
**成功响应**: 返回JSON `{ "status": "success", "session_token": "a-jwt-or-opaque-token" }`。
**失败响应**: 返回401 Unauthorized。

### 6.2 获取控制台信息

```http
GET /api/v1/dashboard
```
**成功响应**: 返回JSON，包含席位信息和设备列表。
```json
{
    "customer_name": "...",
    "seats_info": { "used": 3, "total": 10 },
    "activated_devices": [
        { "hostname": "...", "machine_id": "...", "issued_at": "...", "expires_at": "...", "license_download_link": "/api/v1/licenses/..." }
    ],
    "unbound_devices": [ ... ]
}
```

### 6.3 新设备授权 (批量)

```http
POST /api/v1/actions/activate-licenses
Content-Type: multipart/form-data

// 表单字段:
// bind_files: (multiple file uploads)
```
**成功响应**: 返回一个包含多个`.license`文件的ZIP压缩包。
**失败响应**: 返回JSON错误信息（如席位不足）。

### 6.4 转移授权

```http
POST /api/v1/actions/transfer-license
Content-Type: multipart/form-data

// 表单字段:
// unbind_file: (file upload)
// bind_file: (file upload)
```
**成功响应**: 返回新的`.license`文件流供下载。
**失败响应**: 返回JSON错误信息（如解绑凭证无效）。

### 6.5 注销登录

```http
POST /api/v1/logout
Authorization: Bearer <session_token>
```
**成功响应**: 返回JSON `{ "status": "success", "message": "注销成功" }`。
**失败响应**: 返回401 Unauthorized（如果token无效）。

**说明**: 
- 服务端收到注销请求后，应将对应的`session_token`加入黑名单或从有效token列表中移除。
- 客户端收到成功响应后，应清除本地存储的`session_token`并跳转到登录页面。
- 如果使用JWT token，可以通过维护一个黑名单来实现token失效。
- 如果使用服务端session，直接删除对应的session记录即可。

## 7. 客户端集成方案

### 7.1 Python客户端 (OCR2Doc)

`license_manager.py`需要重构：

```python
# license_manager.py
class LicenseManager:
    def __init__(self, license_path="app.license"):
        # ...

    def get_machine_id(self) -> str:
        """获取机器唯一标识"""
        # ...
    
    def generate_bind_file(self, output_path: str):
        """生成.bind请求文件, 包含机器ID和主机名"""
        # ...

    def import_license_file(self, license_path: str) -> bool:
        """导入并验证.license授权文件"""
        # 1. 验证签名
        # 2. 验证机器ID
        # 3. 保存授权
        # 4. 记录安全时间戳
        # ...

    def generate_unbind_file(self, output_path: str) -> bool:
        """生成.unbind解绑凭证并使本地授权失效"""
        # ...

    def is_license_valid(self) -> (bool, str):
        """
        检查授权有效性。
        返回 (是否有效, 状态信息)
        例如: (True, "正式版, 有效期至 2025-07-30"), 
             (False, "授权已过期"),
             (False, "系统时间异常，请修正")
        """
        # ...
```

### 7.2 功能控制

所有核心功能的入口处，统一调用 `is_license_valid()` 进行检查。

```python
def some_core_function(self, ...):
    is_valid, message = self.config.license_manager.is_license_valid()
    if not is_valid:
        raise Exception(f"操作失败: {message}")
    # ... 执行核心逻辑
```

## 8. 授权模型与扩展

### 8.1 授权码核心属性

每个`authorization_code`都关联了一套核心的授权规则，在签发时确定：
-   `max_seats`: 该授权码下总共可以激活的设备数量上限。
-   `used_seats`: 当前已激活的设备数量。`max_seats - used_seats` 即为剩余可用席位。
-   `duration_years`: 从激活时刻算起，授权的有效年限。可设为99或更大值代表"永久"。
-   `latest_expiry_date`: 一个固定的最晚日期，无论何时激活，授权有效期都不能超过该日期。此字段优先级高于`duration_years`。

### 8.2 授权有效期计算规则

当一个新设备被激活时，其`.license`文件中的有效期`expires_at`按以下规则计算：
-   `expires_at = MIN( 激活时间 + duration_years, latest_expiry_date )`
-   这样做可以灵活地为客户设置"订阅制"（例如，无论何时购买，服务都在特定日期结束）或"激活计时制"的授权模式。

### 8.3 授权扩充与续期

如果客户需要增加授权数量（扩充席位）或延长已购授权的有效期（续期），**推荐的方式是为客户签发一个新的授权码**，并设定新的`max_seats`、`duration_years`或`latest_expiry_date`。

这么设计主要考虑到：
-   **离线设备更新困难**：原授权码下的设备已经离线部署，无法方便地在线更新其授权文件来延长有效期。
-   **规则清晰**: 为新的采购合同签发新的授权码，可以使授权规则、有效期、设备列表的管理更加清晰，避免新旧规则混合造成混乱。

## 9. 授权状态

| 状态 | 描述 | 获取方式 |
|---|---|---|
| **未授权** | 软件无法使用任何核心功能，只能进入激活界面。 | 软件初始状态。 |
| **试用授权** | 功能完整，但有较短的有效期（如30天）。 | 管理员在服务端为特定授权码生成一个短期有效的`.license`文件。 |
| **正式授权** | 功能完整，有较长的有效期（如1年或永久）。 | 客户使用购买的授权码正常激活。 |

---

## 10. 客户端Go示例 (用于测试服务端)

提供一个简单的Go程序，模拟客户端行为，方便 `LicenseCenter` 的独立开发与测试。

```go
package main

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"time"
)

// 模拟获取机器ID
func getMachineID() string {
	// 在真实场景中，这里应该采集CPU、主板、硬盘等硬件信息
	// 为方便测试，我们使用一个固定的字符串
	dummyHardwareInfo := "cpu:intel-i9;motherboard:asus-z790;disk:samsung-980pro"
	hash := sha256.Sum256([]byte(dummyHardwareInfo))
	return hex.EncodeToString(hash[:])
}

// BindFile 文件结构
type BindFile struct {
	Hostname    string    `json:"hostname"`
	MachineID   string    `json:"machine_id"`
	RequestTime time.Time `json:"request_time"`
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("用法: go run . <action>")
		fmt.Println("actions: generate-bind")
		return
	}

	action := os.Args[1]

	switch action {
	case "generate-bind":
		machineID := getMachineID()
		hostname, err := os.Hostname()
		if err != nil {
			hostname = "unknown"
		}
		bindData := BindFile{
			Hostname:    hostname,
			MachineID:   machineID,
			RequestTime: time.Now().UTC(),
		}

		fileData, err := json.MarshalIndent(bindData, "", "  ")
		if err != nil {
			panic(err)
		}

		fileName := "request.bind"
		err = ioutil.WriteFile(fileName, fileData, 0644)
		if err != nil {
			panic(err)
		}
		fmt.Printf("成功生成绑定文件: %s\n", fileName)
		fmt.Printf("主机名: %s\n", hostname)
		fmt.Printf("机器ID: %s\n", machineID)

	default:
		fmt.Println("未知操作:", action)
	}
}
```

将以上代码保存于`LicenseCenter/test_client/main.go`，即可用于生成测试用的`.bind`文件。 